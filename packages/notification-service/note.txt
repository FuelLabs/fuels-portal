const logs = await ethPublicClient.getLogs({
    address: process.env.ETH_FUEL_CHAIN_STATE as `0x${string}`,
    event: {
      type: 'event',
      name: 'CommitSubmitted',
      inputs: abiFuelChainState?.inputs || [],
    },
    fromBlock: BigInt(10920),
  });
  //   const logs = await ethPublicClient.getLogs({
  //               address: process.env.ETH_FUEL_MESSAGE_PORTAL as `0x${string}`,
  //               event: {
  //                 type: 'event',
  //                 name: 'MessageRelayed',
  //                 inputs: abiMessageRelayed?.inputs || [],
  //               },
  //               args: {
  //                 messageId: messageReceipt?.messageId as `0x${string}`,
  //                 // eslint-disable-next-line @typescript-eslint/no-explicit-any
  //               } as any,
  //               fromBlock: 'earliest' as any,
  //             }); --> save to database
  // Save the blocks to the database and the logs
  // Use the latest block to grap the logs
  console.log(logs.length);

  // At the time we insert on the databse we check if is finalized
  // and if the blockHeight is finalized them we save to the block on database that is finalized
  //
  //       // Check if the block is finalized or not
  //       const block = await fuelProvider.getBlock(blockHash);
  //       console.log(block.height);
  //       const isFinalized = await fuelChainState.read.finalized([
  //         blockHash,
  //         block.height.toString(),
  //       ]);
  //   query {
  //     block(id: "0x00") {
  //       header {
  //         height
  //         daHeight
  //         id
  //       }
  //       transactions {
  //         id
  //         receipts {
  //           is
  //           gasUsed
  //           gas
  //           ra
  //           rb
  //           rc
  //           pc
  //           rd
  //           sender
  //           messageId
  //           receipt
  //           param1
  //           param2
  //         } --->>> Interate and save on the database filter by the ones that have receipt type messageOut
  //       }
  //     }
  //   }

  // every X time -> query the database with passing the filter -> transaction from owner that are finalized but not relayed and not sent the email yet
  // Send the message